using System;
using System.Numerics;

namespace Pbrt.Core
{
    /// <summary>
    /// Represents local information at a point on a 2D surface
    /// </summary>
    public class SurfaceInteraction
    {
        /// <summary>
        /// Interaction point.
        /// </summary>
        public Vector3 Point;

        /// <summary>
        /// Interaction time.
        /// </summary>
        public float Time;

        public SurfaceLocalGeometry Geometry;

        /// <summary>
        /// Conservative bound on floating-point error in the Point value.
        /// </summary>
        public Vector3 PointError;

        /// <summary>
        /// Negative ray direction corresponding the outgoing direction when computing lighting points. 
        /// Is Vector3.Zero for other types of interaction points.
        /// </summary>
        public Vector3 Wo;

        public Vector2 UV;

        /// <summary>
        /// Represents possibly perturbed values of the <see cref="Geometry"/> property 
        /// as can be generated by bump mapping or interpolated per-vertex normals with triangles
        /// </summary>
        public SurfaceLocalGeometry ShadingGeometry;

        public SurfaceInteraction(Vector3 point, Vector3 normal, Vector3 pointError, Vector3 wo, float time, 
            Vector2 uv, Vector3 dpdu, Vector3 dpdv, Vector3 dndu, Vector3 dndv, Shape shape)            
        {
            Point = point;
            Time = time;
            PointError = pointError;

            Wo = wo;
            UV = uv;
            Shape = shape;


            
            // Adjust normal based on orientation and handedness
            if (shape != null && 
                (shape.ReverseOrientation ^ shape.TransformSwapsHandedness))
            {
                normal *= -1;                
            }

            var geometry = new SurfaceLocalGeometry(normal, dpdu, dpdv, dndu, dndv);
            Geometry = geometry;
            ShadingGeometry = geometry;
        }

        /// <summary>
        /// The Shape the surface belongs to.
        /// </summary>
        public Shape Shape { get; }

        /// <summary>
        /// Update <see cref="ShadingGeometry"/> when a shading coordinate frame is computed.
        /// </summary>
        public void SetShadingGeometry(Vector3 dpdus, Vector3 dpdvs, Vector3 dndus, Vector3 dndvs, bool orientationIsAuthoritative)
        {
            // <<Compute shading.n for SurfaceInteraction>>
            // << Initialize shading partial derivative values>>
            throw new NotImplementedException();
        }
    }

    public struct SurfaceLocalGeometry
    {
        Vector3 Normal;

        /// <summary>
        /// Partial derivative (U) of the surface (lies in the tangent plane)
        /// </summary>
        Vector3 dpdu;

        /// <summary>
        /// Partial derivative (V) of the surface (lies in the tangent plane)
        /// </summary>
        Vector3 dpdv;

        /// <summary>
        /// Differential change in surface normal as we move U along the surface
        /// </summary>
        Vector3 dndu;

        /// <summary>
        /// Differential change in surface normal as we move V along the surface
        /// </summary>
        Vector3 dndv;

        public SurfaceLocalGeometry(Vector3 normal, Vector3 dpdu, Vector3 dpdv, Vector3 dndu, Vector3 dndv)
        {
            Normal = normal;
            this.dpdu = dpdu;
            this.dpdv = dpdv;
            this.dndu = dndu;
            this.dndv = dndv;
        }
    }
}